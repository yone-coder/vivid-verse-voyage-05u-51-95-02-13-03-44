
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://wkfzhcszhgewkvwukzes.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndrZnpoY3N6aGdld2t2d3VremVzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg3MDE1NzksImV4cCI6MjA1NDI3NzU3OX0.TzSh8M9NOTnsmVaNxquif4xzSxWaVZp9sePHcjrgCVI";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

/**
 * Fetches all products from the database
 */
export const fetchAllProducts = async () => {
  console.log('Fetching all products from database');
  const { data, error } = await supabase
    .from('products')
    .select('*, product_images(*)');
  
  if (error) {
    console.error('Error fetching products:', error);
    throw error;
  }
  
  return data || [];
};

/**
 * Fetches a single product by ID
 */
export const fetchProductById = async (productId: string) => {
  console.log(`Fetching product with ID: ${productId}`);
  const { data, error } = await supabase
    .from('products')
    .select('*, product_images(*)')
    .eq('id', productId)
    .single();
  
  if (error) {
    console.error(`Error fetching product ${productId}:`, error);
    throw error;
  }
  
  return data;
};

/**
 * Creates a new product in the database
 */
export const createProduct = async (productData: any) => {
  console.log('Creating new product with data:', productData);
  
  const { data, error } = await supabase
    .from('products')
    .insert(productData)
    .select();
  
  if (error) {
    console.error('Error creating product:', error);
    throw error;
  }
  
  return data;
};

/**
 * Updates a product by ID
 */
export const updateProduct = async (productId: string, updates: any) => {
  console.log(`Updating product ${productId} with:`, updates);
  
  // First, check if there are actually changes to make
  const { data: existingProduct } = await supabase
    .from('products')
    .select('*')
    .eq('id', productId)
    .single();
  
  // Check if there are any actual changes to make
  if (existingProduct) {
    let hasChanges = false;
    for (const key in updates) {
      if (updates[key] !== existingProduct[key]) {
        hasChanges = true;
        break;
      }
    }
    
    if (!hasChanges) {
      console.log('No actual changes detected, skipping update');
      return { noChanges: true };
    }
  }
  
  // Proceed with the update
  const { data, error } = await supabase
    .from('products')
    .update(updates)
    .eq('id', productId)
    .select();
  
  if (error) {
    console.error(`Error updating product ${productId}:`, error);
    throw error;
  }
  
  return data;
};

/**
 * Sets up a subscription to product changes
 */
export const subscribeToProductChanges = (callback: () => void) => {
  console.log('Setting up subscription to product changes');
  
  const channel = supabase
    .channel('product-changes')
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'products'
      },
      () => {
        callback();
      }
    )
    .subscribe((status) => {
      console.log('Product subscription status:', status);
    });
  
  // Return a cleanup function
  return () => {
    console.log('Removing product changes subscription');
    supabase.removeChannel(channel);
  };
};
